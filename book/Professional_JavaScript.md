# Professional JavaScript
第三版-2012年3月

----
# 全书疑问点：
----
 - “property 是最独特的属性”这句话有吗? 在哪里?
 - P203 “返回一个XX”
 - P412 在 HTML 中，表单是由`<form>`元素来表示的，而在 JS 中，表单对应的则是 HTMLFormELement 类型。HTMLFormElement 继承了 HTMLElement，因此与其他 HTML 元素具有相同的默认属性

----
# 第5章 引用类型
----
- ## 5.1 Object 类型
- new Object() / var person = {} / 
- ## 5.2 Array 类型
	- ### 5.2.1 检测数组
		- _P88 如果你从一个框架向另一个框架传入一个数组，那么传入的数组与在第二个框架中的原生创建的数组分别具有各自不同的构造函数_
- ## 5.5 Function 类型
	- ### 5.5.1 没有重载（深入理解）
	- ### 5.5.2 函数声明与函数表达式
	- ### 5.5.3 作为值的函数
	- ### 5.5.4 函数内部属性
		- P113 在函数内部，有两个特殊的对象：_arguments 和 this_。其中，_arguments_ 在第 3 章曾经介绍过，它是一个_类数组对象_，包含着传入函数中的所有参数。虽然 arguments 的主要用途是保存函数参数，但这个对象还有一个名叫 _callee_ 的属性，该属性是一个指针，指向拥有这个 arguments 对象的函数。
		- P114 函数内部的另一个特殊的对象 _this_。this 指向的是函数据以执行的环境对象——或者也可以说是 this 值。
		- P115 由于在调用函数之前，this 的值并不确定，因此 this 可能会在代码执行过程中引用不同的对象。
		- P115 请读者一定要牢记，函数的名字仅仅是一个包含指针的变量而已。因此，即使是在不同的环境中执行，全局的 sayColor() 函数与 o.sayColor() 指向的仍然是同一个函数
		- P115 _caller_ 保存着调用当前函数的函数的引用
		- P115 以上变化都是为了加强这门语言的安全性，这样第三方代码就不能再相同的环境里窥视其他代码了。
	- ### 5.5.5 函数属性和方法
		- P116 每个函数都包含两个属性：length 和 prototype。前者表示函数希望接收的命名参数的个数
		- P117 _call()_，_apply()_：它们真正强大的地方是能够扩充函数赖以运行的作用域
		- P118 _bind()_，这种技巧的优点请参考第 22 章
- ## 5.6 基本包装类型
- P118 实际上，每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而让我们能够调用一些方法来操作这些数据。
- P133 代码注入
- ## 5.5 Function 类型
	- ### 5.5.5 函数的属性和方法
		- P118 使用 call() (或者 apply())来扩充作用域的最大好处，就是对象不需要与方法有任何耦合关系。

----
# 第6章 面向对象的程序设计
----
- ## 6.1 理解对象
	- ### 6.1.1 属性类型
		- #### 1. 数据属性
		- #### 2. 访问器属性
	- ### 6.1.2 定义多个属性
	- ### 6.1.3 读取属性的特性
- ## 6.2 创建对象
	- ### 6.2.1 工厂模式
	- ### 6.2.2 构造函数模式
		- P145 `constructor` `instanceof`
		- P145 要创建一个 Person 对象的新实例，必须使用 `new` 操作符。以这种方式调用构造函数实际上会经历以下 4 个步骤：(1)创建一个新对象；(2)将构造函数的作用域赋给新对象(因此，`this` 就指向了这个新对象)；(3)执行构造函数中的代码(为这个新对象添加属性)；(4)返回新对象；
		- ####1. 将构造函数当当作函数
			- P146 构造函数与其他函数的唯一区别，就在于调用它们的方式不同。不过，构造函数毕竟也是函数，不存在定义构造函数的特殊语法。任何函数，只要通过 `new` 操作符来调用，那它就可以作为构造函数；而任何函数，如果不通过 `new` 操作符来调用，那它跟普通函数也不会有什么两样。
			- P146 读者可能还记得，当在全局作用域中调用一个函数时，`this` 对象总是指向 `Global`
		- #### 2. 构造函数的问题
	- ### 6.2.3 原型模式
		- ####1. 理解原型对象
			- P148 不过，要明确的真正重要的一点就是，这个链接存在与实例与构造函数的原型对象之间，而不是存在于实例与构造函数之间。
			- P149 `Person.prototype.isPrototypeOf(person1)` 确定某个原型是否是某个实例的原型对象
			- P149 `Object.getPrototypeOf(person1) == Person.prototype` 可以方便地取得一个对象的原型
			- P150 `person1.hasOwnProperty("name")` 检测一个属性存在于实例还是原型，只有存在于实例时才返回`ture`
		- ####2. 原型与 in 操作符
			- P154 `Object.keys()` 这个方法接收一个对象作为参数，返回一个包含所有可枚举属性的字符串数组
			- P154 `Object.getOwnPropertyName` 如果你想得到所有实例的属性，无论它是否可以枚举，都可以使用这个
		- ####3. 更简单的原型语法
			- P155 `Object.defineProperty` 默认情况下，原生的`constructor`属性是不可枚举的
		- ####4. 原型的动态性
			- P156 尽管可以随时为原型添加属性和方法，并且修改能够立即在所有对象实例中反映出来，但如果是重写整个原型对象，那么情况就不一样了。（重写原型对象会切断现有原型与任何值钱已经存在的对象实例之间的联系）
		- ####5. 原生对象原型
		- ####6. 原型对象的问题
	- ###6.2.4 组合使用构造函数模式和原型模式
	- ###6.2.5 动态原型模式
	- ###6.2.6 寄生构造函数模式
	- ###6.2.7 稳妥构造函数模式
- ##6.3 继承
	- ###6.3.1 原型链
		- ####1. 别忘记默认的原型
		- ####2. 确定原型和实例的关系
		- ####3. 谨慎地定义方法
			- _P166 为什么这里重写这个方法是屏蔽而不是重写呢?_
				- 应该好理解，原型链向上找的过程，本来就有一个空位，看 P163 的图
		- ####4. 原型链的问题
	- ###6.3.2 借用构造函数
		- ####1. 传递参数
		- ####2. 借用构造函数的问题
	- ###6.3.3 组合继承
	- ###6.3.4 原型式继承
	- ###6.3.5 寄生式继承
	- ###6.3.6 寄生组合式继承
- ##6.4 小结

---
#第8章 BOM
---

- _P203 setTimeout() ：由于传递字符串可能导致性能损失，因此不建议以字符串作为第一个参数_
- P205 一般认为，使用超时调用来模拟间歇调用是一种最佳实践

---
#第9章 客户端检测
---
- P219 IE8 typeof document.createElement 会返回 object 而不是 function
【P219 function isHostMethod(object, property)
答：双逻辑非操作符

- P220 双逻辑非操作符

- _P229 如果 Firefox、Chrome 和 Netscape 都使用相同版本的 Gecko，那它们一定支持相同的特性。
除了渲染引擎提供的特性，没有其他特性吗?_
	- 答：P232 “苹果公司的 Safari 浏览器和谷歌公司的 Chrome 浏览器都使用 WebKit 作为呈现引擎，但它们的 JS 引擎却不一样”

- _P229 为了不在全局作用域中添加多余的变量，我们将使用模块增强模式来封装检测脚本_

- P246 小结：能力检测、怪癖检测、用户代理检测

----
#第10章 DOM
----
- ##10.1 节点层次
	- _P248 总共有12种节点类型，这些类型都继承自一个基类型_
		- _基类型是 Node 类型?_
	- ###10.1.1 Node 类型
		- P249 对于元素节点，nodeName 中保存的始终都是元素的标签名，而 nodeValue 的值则始终为 null
		- P249 .appendChild(someNode) 会返回 someNode，同样 insertBefore() 也会返回那个节点
		- P251 如果传入到 appendChild() 中的节点已经是文档的一部分了，那结果就是讲该节点从原来的位置转移到新位置。
		- P252 前面介绍的四个方法操作的都是某个节点的子节点
		- P253 deepList.childNodes.length 中的差异主要是因为 IE8 及更早版本与其他浏览器处理空白字符的方式不一样
		- P253 Node 的 normalize() 方法
	- ###10.1.2 Document 类型
		- P254 在浏览器中，document 对象是 HTMLDocument（继承字 Document 类型）的一个实例，表示整个 HTML 页面
		- P254 因为开发人员经常要使用这个元素，所以 document.body 在 JavaScript 代码中出现的频率非常高
		- P255 修改 title 属性的值不会改变 `<title>` 元素
		- P255 3个与页面请求有关的 document 对象属性：URL、domain 和 referrer
			- domain 是 www.XXX.com，是 URL 的一部分，而不是 IP 地址
		- P257 IE8 及较低版本不区分 ID 的大小写
		- _P257 在 HTML 文档中，这个方法会返回一个 HTMLCollection 对象_
			- 这里的 HTMLCollection 对象是指对象的名字? 前面有很多类似的说法，什么 NodeList 对象等等
		- P257 与 NodeList 对象类似，可以使用方括号语法或 item() 方法来访问 HTMLCollection 对象中的项
		- P257 在后台，对数值索引就会调用 item() ，而对字符串索引就会调用 namedItem()
		- P260 `</script>` 在 document.write 中时要把 / 采用转移字符取代
	- ###10.1.3 Element 类型
		- _P262 HTMLElement 类型直接继承自 Element 并添加了一些属性_
			- 这里的 Element 和 “继承自” 都是什么意思?
		- P263 所有 HTML 元素都是由 HTMLElement 或者其更具体的子类型（看P263 的那张表里的类型名称，比如有 HTMLHeadingElement）来表示的。
			- _为什么要有那么多的子类型?_
		- P264 因此要想得到 class 特性值，应该传入“class”而不是"className"
		- P264 特性的名称是不区分大小写的，即“ID”和“id”代表的都是同一个特性
		- P264 “自定义特性” “另外也要注意，根据HTML5规范，自定义特性应该加上 data- 前缀以便验证”
		- _P265 align_
		- P265 有两类特殊的特性，一类是 style，另一类是 onclick 这样的事件处理程序
		- P265 由于存在这些差别，在通过 JS 以编程方式操作 DOM 时，开发人员经常不使用 getAttribute()，而是只是用对象的属性，只有在取得自定义特性值的情况下，才会使用 get
		- P269 但如果是在其他浏览器中，`<ul>` 元素都会有7个元素，包括3个`<li>`元素和4个文本节点（表示`<li>`元素之间的空白符）
			- 这里 `<li>` 里面的 Item 1 文本是属于 `<li>` 的子节点而不是 `<ul>` 的
	- ###10.1.4 Text 类型
		- P271 此时的字符串会经过 HTML 编码
		- P272 normalize() 的作用
	- ###10.1.5 Comment 类型
		- _P273 基类：Comment 类型与 Text 类型继承自相同的基类_
	- ###10.1.6 CCDATASection 类型（只针对基于 XML 的文档）
	- ###10.1.7 DocumentType 类型
		- P275 document.doctype
	- ###10.1.8 DocumentFragment 类型
		- P275 在所有节点类型中，只有 DocumentFragment 在文档中没有对应的标记（就是没有加入到文档流中的文档碎片）
		- P276 实际上只会将文档片段的所有子节点添加到相应位置上；文档片段本身永远不会成为文档树的一部分
	- ###10.1.9 Attr 类型
		- _P276 元素的特性在 DOM 中以 Attr 类型来表示。在所有浏览器中，都可以访问 Attr 类型的构造函数和原型。从技术角度讲，特性就是存在于元素的 attributes 属性中的节点_
- ##10.2 DOM 操作技术
	- ###10.2.1 动态脚本
		- P279 动态脚本，通过 var script = document.createElement(“script”); 创建，动态加载的外部 JS 文件能够立即运行
			- _封装一个 loadScript(url) 函数就可以加载外部 JS 文件了，但是有一个问题：如何知道脚本加载完成呢? 见 13章_
	- ###10.2.2 动态样式
		- P280 加载外部样式文件的过程是异步的，也就是加载样式与执行 JS 代码的过程没有固定的次序。一般来说，知不知道样式已经加载完成并不重要。
		- _很多处地方都会提到 “IE 会报错”，却没有指明什么版本的 IE 会报错，估计写这本书的时候的所有 IE 都有问题吧? 书是 2012 年初出版的，而 IE10 在 2011 年就已经有了，IE11 要到 2013 年，也就是说 IE10 之前的版本都有兼容性问题?_
	- ###10.2.3 操作表格
	- ###10.2.4 使用 NodeList
		- P283 理解 NodeList 及其“近亲” NameNodeMap 和 HTMLCollection，是从整体上透彻理解 DOM 的关键所在。这三个集合都是“动态的”

----
#第11章 DOM 扩展
----
- P286 对 DOM 的两个主要的扩展是 Selector API（选择符 API）和 HTML5

- ##11.1 选择符 API
	- P286 而把这个功能编程原生 API 之后，解析和树查询操作可以在浏览器内部通过编译后的代码来完成，极大地改善了性能
	- _P287 querySelectorAll() 返回的值实际上是带有所有属性和方法的 NodeList，其底层实现则类似于一组元素的快照，而非不断对文档进行搜索的动态查询。这样的实现可以避免使用 NodeList 对象通常会引起的大多数性能问题_
- ##11.2 元素遍历
	- P288 childElementCount firstElementChild 等
- ##11.3 HTML5
	- P289 对于传统 HTML 而言，HTML5 是一个叛逆。
	- ###11.3.1 与类相关的扩充
		- P289 getElementsByClassName() 最早出现在 JS 库中，是通过既有的 DOM 功能实现的，而原生的实现具有极大的性能优势
		- P290 不过别忘了，因为返回的对象是 NodeList，所以使用这个方法与使用 getElementsByTagName() 以及其他返回 NodeList 的 DOM 方法具有同样的性能问题
		- _P290 这个 classList 属性是新集合类型 DOMTokenList 的实例_
			- classList IE 只有 edge 支持
	- ###11.3.2 焦点管理
		- P292 通过检测文档是否获得了焦点，可以知道用户是不是正在与页面交互；查询文档获知哪个元素获得了焦点，以及确定文档是否获得了焦点，这两个功能最重要的用途是提高 Web 应用的无障碍性。无障碍 Web 应用的一个主要标志就是恰当的焦点管理
	- ###11.3.3 HTMLDocument 的变化
	- ###11.3.4 字符集属性(document.charset)
	- ###11.3.5 自定义数据属性
		- _P294 自定义数据属性 data-；如果需要给元素添加一些不可见的数据一遍进行其他处理，那就要用到自定义数据属性。在跟踪链接或混搭应用中，通过自定义数据属性能方便地知道点击来自页面中的哪个部分_
	- ###11.3.6 插入标记
		- _P294 一下（innerHTML）与插入标记相关的 DOM 扩展已经纳入了 HTML5 规范；_
			- DOM 扩展? 这难道不是 HTML-dom 么?
		- P295 并不是所有元素都支持 innerHTML 属性。不支持 innerHTML 的元素有：col colgrounp frameset head html style table tbody thead tfoot tr
		- P297 使用本节介绍的方法替换子节点可能会导致浏览器的内存占用问题
		- P297 在插入大量新 HTML 标记时，使用 innerHTML 属性与通过多次 DOM 操作先创建节点再指定他们之间的关系相比，效率要高很多，因为使用 innerHTML 或 outerHTML 会创建一个 HTML 解析器，这是一个浏览器级别代码（通常是 C++）基础上运行的，因此比执行 JS 快得多。但是创建和销毁 HTML 解析器也会产生性能损失，也要避免重复多次无意义地使用 innerHTML
- ##11.4 专有扩展
	- 即便如此，仍然有大量专有 DOM 扩展没有成为标准。但这并不是说它们将来不会被写进标准
	- ###11.4.1 文档模式
		- P299 通过设置 `<meta http-equiv=“X-UA-Compatible” content=“????”>` 来设置采用哪种文档模式
		- P299 document.documentMode
	- ###11.4.2 children 属性
	- ###11.4.3 contains( ) 方法
	- ###11.4.4 插入文本
		- P302 利用 innerText 的这一点特性，可以用它过滤掉 HTML 标签，div.innerHTML = div.innerHTML
	- ###11.4.5 滚动
		- P303 scrollIntoView( ) scrollIntoViewIfNeeded() scrollByLines() scrollByPages()

----
#第12章 DOM2 和 DOM3
----
- ##12.1 DOM 变化
	- _P305 很大程度上意味着对命名空间的支持；增强了既有类型；引入了一些新类型_
	- ###12.1.1 针对 XML 命名空间的变化
		- _P306 命名空间_
		- P306 在只基于一种语言编写 XML 文档的情况下，命名空间实际上也没有什么用。不过，在混合使用两种语言的情况下，命名空间的用处就非常大了。来看一下下面这个混合了 XHTML 和 SVG 语言的文档：
		- P307 对于类似这样的文档来说，最右意思的事发生在调用方法操作文档节点的情况下
		- P309 由于一般都是通过元素访问特性，所以这些方法很少使用
	- ###12.1.2 其他方面的变化
		- P309 实际上，很少需要在网页中访问此类信息
		- P310 importNode 这个方法在 HTML 文档中并不常用，在 XML 文档中用得比较多（更多讨论请参见第 18 章）
		- P311 Node 类型的变化：isSupported() 为此，我们建议在确定某个特性是否可用时，最好还是使用能力检测
- ##12.2 样式
	- ###12.2.1 访问元素的样式
		- _P313 任何支持 style 特性的 HTML 元素在 JS 中都有一个对应的 style 属性。这个 style 对象时 CSSStyleDeclaration 的实例_
		- P313 对于使用短划线的 CSS 属性名，必须将其转换成驼峰大小写形式
		- P313 其中一个不能直接转换的 CSS 属性就是 float。由于 float 是 JS 中的保留字，因此不能用作属性名。“DOM2级样式”规范规定，float 对应的属性名是 cssFloat，IE 里是 styleFloat
		- P313 在实践中，最好始终指定度量单位
		- P315 document.defaultView.getComputedStyle()：虽然 style 对象能够提供支持 style 特性的任何元素的样式信息，但它不包含那些从其他样式表层叠而来的并影响到当前元素的样式信息
			- getComputedStyle() 方法返回一个 CSSStyleDeclaration 对象（与 style 属性的类型相同），其中包含当前元素的所有计算的样式
		- P316 存在这个差别的原因是不同浏览器解析综合属性（如 border background 的方式不同），因为设置这种属性实际上会涉及很多其他样式
		- P316 无论在哪个浏览器中，最重要的一条是要记住所有计算的样式都是只读的
	- ###12.2.2 操作样式表
		- _P317 CSSStyleSheet HTMLinkElement HTMLStyleElement 这三者的关系：有读者可能记得，这两个元素本身分别是由 HTMLinkElement 和 HTMLStyleElement 类型表示的，但是 CSSStyleSheet 类型相对更加通用一些_
		- P317 CSSStyleSheet 继承自 StyleSheet，后者可以作为一个基础接口来定义非 CSS 样式表。
		- ####1. CSS 规则
			- P318 CSSRules 对象：其中三个最常用的属性是 cssText、selectorText 和 style；cssText 属性与 style.cssText 属性类似，但并不相同。
			- P319 大多数情况下，仅使用 style 属性就可以满足所有操作样式的需求了
		- ####2. 创建规则
			- P320 虽然可以像这样来添加规则，但随着要添加的样式的增多，这种方法就会变得非常繁琐。如果要添加的规则很多，我们还是建议采用第10章介绍过的动态加载样式表的技术
		- ####3. 删除规则
			- P320 与添加规则类似，删除规则也不是实际 Web 开发中常见的做法。
	- ###12.2.3 元素大小
		- ####1. 偏移量
			- offsetHeight
			- offsetWidth
			- offsetLeft
			- offsetTop
			- P321 要想知道元素在页面上的偏移量，将这个元素的 offsetLeft 等值根据父元素累积相加之后即可
			- _P322 getElementLeft() ?_
				- P325 “本章前面定义的 getElementLeft()”
		- ####2. 客户区大小
			- clientWidth clientHeight
			- _P322 这两个属性难道不能通过 width + 2*padding 获得吗? 还要另外特地设置这两个属性?_
		- ####3. 滚动大小
			- scrollHeight
			- scrollWidth
			- scrollLeft
			- scrollTop
		- ####4. 确定元素大小
			- getBoundingClientRect()
			- P325 需要兼容 IE8，IE8 左上角坐标是 (2, 2)
			- _P325 arguments.callee.offset_
- ##12.3 遍历
	- _P326 深度优先（depth-first）的遍历操作_
	- ###12.3.1 NodeIterator
	- ###12.3.2 TreeWalker
		- P330 TreeWalker 是 NodeIterator 的更高级版本
		- P331 由于这两个创建方法很相似，所以很容易用 TreeWalker 来代替 NodeIterator
		- P331 TreeWalker 真正强大的地方在于能够在 DOM 结构中沿任何方向移动
- ##12.4 范围
	- P332 在常规的 DOM 操作不能更有效地修改文档时，使用范围往往可以达到目的
	- ###12.4.1 DOM 中的范围
		- ####1. 用 DOM 范围实现简单选择
		- ####2. 用 DOM 范围实现复杂选择
		- ####3. 操作 DOM 范围中的内容
			- P335 像这样创建了范围之后，就可以使用各种方法对范围的内容进行操作了
		- ####4. 插入 DOM 范围中的内容
		- ####5. 折叠 DOM 范围
		- ####6. 比较 DOM 范围
		- ####7. 复制 DOM 范围
		- ####8. 清理 DOM 范围
	- ###12.4.2 IE8 及更早版本中的范围
- ##12.5 小结

----
#第13章 事件
----
- P345 浏览器的事件系统相对比较复杂。尽管所有主流浏览器已经实现了“DOM2 级时间”，但这个规范本身并没有涵盖所有事件类型。浏览器对象模型（BOM）也支持一些事件，但是这些时间与文档对象模型（DOM）时间之间的关系并不十分清晰，因为 BOM 事件长期没有规范可以遵循（HTML5 后来给出了详细说明）。随着 DOM3 级的出现，增强后的 DOM 事件 API 变得更加繁琐。使用事件有时相对简单，有时则非常复杂，难易程度会因你的需求而不同。不过，有关时间的一些核心概念是一定要理解的。

- ##13.1 事件流

	- ###13.1.1 事件冒泡

	- ###13.1.2 事件捕获
		- P347 由于老版本的浏览器不支持，因此很少有人使用事件捕获。我们也建议读者放心使用事件冒泡，在右特殊需要的时候再使用事件捕获。

	- ###13.1.3 DOM 事件流
		- P348 结果，就是有两个机会在目标对象上面操作事件
		- P348 IE8 及更早版本不支持 DOM 事件流
- ##13.2 事件处理程序

	- ###13.2.1 HTML 事件处理程序
		- P348 这个函数中有一个局部变量 event，也就是事件对象
		- P349 在这个函数内部，this 值等于事件的目标元素
		- _P349 这个函数使用 with 像下面这样扩展作用域_
		- _P350 事件处理程序的作用域链；非限定对象_
	- ###13.2.2 DOM0 级事件处理程序
		- P350 将一个函数赋值给一个事件处理程序属性
		- P350 使用 DOM0 级方法制定的事件处理程序被认为是元素的方法。因此，这时候的事件处理程序是在元素的作用域中运行；换句话说，这时 this 引用当前元素。
		- P350 以这种方式添加的事件处理程序会在事件流的冒泡阶段被处理
	- ###13.2.3 DOM2 级事件处理程序
		- addEventListener() removeEventListener()
		- P351 与 DOM0 级方法一样，这里添加的事件处理程序也是在其依附的元素的作用域中运行。
		- P351 这两个事件处理程序会按照添加它们的顺序触发
		- P351 通过 addEventListener() 添加的事件处理程序只能使用 removeEventListener() 来移除；移除时传入的参数和添加时相同。这也意味着通过 addEventListener() 添加的匿名函数将无法移除
		- P352 大多数情况下，都是将事件处理程序添加到事件流的冒泡阶段，这样可以最大限度地兼容各种浏览器。最好只在需要在事件到达目标之前截获它的时候将事件处理程序添加到捕获阶段
	- ###13.2.4 IE 事件处理程序
		- P352 由于 IE8 及更早版本只支持事件冒泡
		- P353 在 IE 中使用 attachEvent() 与使用 DOM0 级方法的主要区别在于事件处理程序的作用域。attachEvent() 方法会在全局作用域中运行，所以 this 等于 window
		- P353 不过，与 DOM 方法不同的是，这些事件处理程序不是以添加它们的顺序执行，而是以相反的顺序被触发
	- ###13.2.5 跨浏览器的事件处理程序
		- P354 此时，我们使用的是方括号语法来...
		- P355 这里这两个函数没有考虑到所有的浏览器问题，例如在 IE 中的作用域问题。
		- P355 此外还要注意，DOM0 级对每个事件只支持一个事件处理程序。好在只支持 DOM0 级的浏览器已经没有那么多了
- ##13.3 事件对象
	- P355 event 对象，这个对象包含着所有与事件有关的信息。包括导致事件的元素、事件的类型以及其他与特定事件相关的信息
	- ###13.3.1 DOM 中的事件对象
		- _P356 this currentTarget target 之间的关系；事件处理程序内部，currentTarget 始终等于 this_
		- 这里的代码示例意思是，body 是没有 onclick 事件的，所以 body.onclick = function… 之后的话，实际上是要去绑定上 body 里面的 button 的是吗? 那如果 body 里面有 2 个以上的 button 呢? 绑定给谁呢?
		- _P358 “尽管‘处于目标’发生在冒泡阶段，但 eventPhase 仍然一直等于2”_
	- ###13.3.2 IE 中的事件对象
		- 又和 DOM 中的不一样
		- _P360 “但 stopPropagation() 可以同时取消事件捕获和冒泡。例如：”，但是下面的例子里面没有用到 stopPropagation() 啊?_
	- ###13.3.3 跨浏览器的事件对象

- ##13.4 事件类型
	- _P361 getEvent() 和 getTarget()_
	- ###13.4.1 UI 事件
		- P362 这些事件在 DOM 规范出现之前，都是以这种或那种形式存在的，而在 DOM 规范中保留是为了向后兼容
		- P363 当 图像、框架、嵌入的内容 加载完毕之后都会触发 load、unload 等事件
		- P364 一般来说，在 window 上面发生的任何事件都可以在 `<body>` 元素中通过相应的特性来指定，因为在 HTML 中无法访问 window 元素。实际上，这只是为了保证向后兼容的一种权宜之计，但所有的浏览器都能很好地支持这种方式
		- P364 根据 “DOM2 级事件” 规范，应该在 document 而非 window 上面触发 load 事件。但是，所有浏览器都在 window 上面实现了该时间，以确保向后兼容
		- P364 此时，最重要的是要在指定 src 属性之前先指定事件
		- P365 Image 对象：var image = new Image();
		- P365 新图像元素不一定要从添加到文档之后才开始下载，只要设置 src 属性就会开始下载
		- P365 还有一些元素以非标准的方式支持 load 事件。比如`<script>`，以便开发人员确定动态加载的 JavaScript 文件是否加载完毕。与图像不同，只有在设置了 src 属性并将该元素添加到文档之后，才会开始下载 JS 文件
		- P366 unload 的常用场景：清楚引用，避免内存泄露
		- P367 resize，FF 只会在用户停止调整窗口大小时才会触发 resize 事件
		- _P367 scroll_
	- ###13.4.2 焦点事件
		- P367 利用这些事件并与 document.hadFocus() 方法以及 document.activeElement 属性配合，可以知晓用户在页面上的行踪
		- _P368 这一类事件中最主要的 2 个是 focus、blur…._
	- ###13.4.3 鼠标与滚轮事件
		- _P368 不少事件提到“这个事件不冒泡”，有什么意义?_
		- P369 鼠标事件与其他事件是密不可分的关系
		- P369 注意，DOM3 级事件的 feature 名是 “MouseEvent” 而不是“MouseEvents”
		- ####1. 客服区坐标位置
		- ####2. 页面坐标位置
		- ####3. 屏幕坐标位置
			- P370 clientX clientY / pageX pageY / screenX screenY
		- ####4. 修改键
			- P372 修改键：shiftKey、ctrlKey、altKey、metaKey
		- ####5. 相关元素
			- P373 relatedTarget
		- ####6. 鼠标按钮
		- ####7. 更多的事件信息
		- ####8. 鼠标滚轮事件
			- _P378 这里我们将相关代码放在了一个私有作用域中，从而不会让新定义的函数干扰全局作用域_

					(function(){
						XXXX
					})();
		- ####9. 触屏设备
		- ####10. 无障碍性问题
	- ###13.4.4 键盘与文本事件
		- P379 keydown keypress keyup textInput
		- ####1. 键码
		- ####2. 字符编码
			- P381 IE 兼容
		- ####3. DOM3 级变化
		- ####4. textInput 事件
		- ####5. 设备中的键盘事件
	- ###13.4.5 复合事件
	- ###13.4.6 变动事件
		- P386 事件：DOMSubtreeModified DOMNodeInserted DOMNodeRemoved
		- ####1. 删除节点
		- ####2. 插入节点
	- ###13.4.7 HTML5 事件
		- ####1. contextmenu 事件
		- ####2. beforeunload 事件
		- ####3. DOMContentLoaded 事件
		- ####4. readystatechange 事件
		- ####5. pageshow 和 pagehide 事件
		- ####6. hashchange 事件
			- P394 之所以新增这个事件，是因为在 Ajax 应用中，开发人员经常要利用 URL 参数列表来保存状态或导航信息
			- _P395 理解这行代码_
	- ###13.4.8 设备事件
		- ####1. orientationchange 事件
		- ####2. MozOrientation 事件
		- ####3. deviceorientation 事件
		- ####4. devicemotion 事件
	- ###13.4.9 触摸与手势事件
		- P399 随着 Android 中的 WebKit 的加入，很多这样的专有事件变成了事实标准，导致 W3C 开始制定 Touch Events 规范
		- P400 触摸事件和手势事件之间存在某种关系
		- ####1. 触摸事件
		- ####2. 手势事件
- ##13.5 内存和性能
	- P402 可是在 JS 中，添加到页面上的事件处理程序数量将直接关系到页面的整体运行性能。...
	- ###13.5.1 事件委托
		- P402 事件委托利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件
		- _P403 而且它们的事件会冒泡，所以单击事件最终会被这个函数处理_
			- _为什么不直接全部在 document 上注册事件处理程序呢?_
	- ###13.5.2 移除事件处理程序
		- P404 在不需要的时候移除事件处理程序，也是提高性能的方法。有两种情况，会造成上述问题：
			- 一. 从文档中移除带有事件处理程序的元素时：removeChild replaceChild innerHTML(尤其是innerHTML)，解决办法：
				- 手动设置 target.onclick = null
				- 事先知道将来可能使用 innerHTML，可以采用事件委托
			- 二. 卸载页面的时候，解决办法
				- 用 onunload 事件处理程序移除所有事件处理程序，通过事件委托减少需要跟踪的事件处理程序
		- _P405 注意，在事件处理程序中删除按钮也能阻止事件冒泡_
- ##13.6 模拟事件
	- P405 在测试 Web 应用程序的时候，模拟触发事件是一种极其有用的技术
	- ###13.6.1 DOM 中的事件模拟
		- P405 事件名称，DOM2 中用复数，DOM3 中用单数
		- ####1. 模拟鼠标事件
		- ####2. 模拟键盘事件
		- ####3. 模拟其他事件
		- ####4. 自定义 DOM 事件
	- ###13.6.2 IE 中的事件模拟
- ##13.7 小结
	- P411 事件是 JS 中最重要的主题之一，深入理解事件的工作机制以及它们对性能的影响至关重要

----
#第14章 表单脚本
----
- ##14.1 表单的基础知识
	- ###14.1.1 提交表单
	- ###14.1.2 重置表单
	- ###14.1.3 表单字段
		- ####1. 共有的表单字段属性
		- ####2. 共有的表单字段方法
		- ####3. 共有的表单字段事件
- ##14.2 文本框脚本
	- ###14.2.1 选择文本
	- ###14.2.2 过滤输入
	- ###14.2.3 自动切换焦点
	- ###14.2.4 HTML5 约束验证 API
- ##14.3 选择框脚本
	- ###14.3.1 选择选项
	- ###14.3.2 添加选项
	- ###14.3.3 移除选项
	- ###14.3.4 移动和重排选项
- ##14.4 表单序列化
- ##14.5 富文本编辑
	- ###14.5.1 使用 contenteditable 属性
	- ###14.5.2 操作富文本
	- ###14.5.3 富文本选区
	- ###14.5.4 表单与富文本
- ##14.6 小结

----
#第15章 使用 CANVAS 绘图
----
- ##15.1 基本用法
- ##15.2 2D 上下文
	- ###15.2.1 填充和描边
	- ###15.2.2 绘制矩形
	- ###15.2.3 绘制路径
	- ###15.2.4 绘制文本
	- ###15.2.5 变换
	- ###15.2.6 绘制图像
	- ###15.2.7 阴影
	- ###15.2.8 渐变
	- ###15.2.9 模式
	- ###15.2.10 使用图像数据
	- ###15.2.11 合成
- ##15.3 WebGL
	- ###15.3.1 类型化数组
		- ####1. 视图
		- ####2. 类型化视图
	- ###15.3.2 WebGL 上下文
		- ####1. 常量
		- ####2. 方法命名
		- ####3. 准备绘图
		- ####4. 适口与坐标
		- ####5. 缓冲区
		- ####6. 错误
		- ####7. 着色器
		- ####8. 编写着色器
		- ####9. 编写着色器程序
		- ####10. 为着色器传入值
		- ####11. 调试着色器和程序
		- ####12. 绘图
		- ####13. 纹理
		- ####14. 读取像素
	- ###15.3.3 支持
- ##15.4 小结

----
#第16章 HTML5 脚本编程
----
- ##16.1 跨文档消息传递
- ##16.2 原生拖放
	- ###16.2.1 拖放事件
	- ###16.2.2 自定义放置目标
	- ###16.2.3 dataTransfer 对象
	- ###16.2.4 dropEffect 与 effectAllowed
	- ###16.2.5 可拖动
	- ###16.2.6 其他成员
- ##16.3 媒体元素
	- ###16.3.1 属性
	- ###16.3.2 事件
	- ###16.3.3 自定义媒体播放器
	- ###16.3.4 检测编解码器的支持情况
	- ###16.3.5 Audio 类型
- ##16.4 历史状态管理
- ##16.5 小结

----
第17章 错误处理与调试
----
- ##17.1 浏览器报告的错误
	- ###17.1.1 IE
	- ###17.1.2 Firefox
	- ###17.1.3 Safari
	- ###17.1.4 Opera
	- ###17.1.5 Chrome
- ##17.2 错误处理
	- ###17.2.1 try-catch 语句
		- ####1. finally 字句
		- ####2. 错误类型
		- ####3. 合理使用 try-catch
	- ###17.2.2 抛出错误
		- ####1. 抛出错误的时机
		- ####2. 抛出错误与使用 try-catch
	- ###17.2.3 错误（error）事件
		- P505 _在任何 Web 浏览器中，onerror 事件处理程序都不会创建 event 对象，但它可以接收三个参数：错误消息、错误所在的 URL 和行号_

				window.onerror = function(message, url, line) {
					alert(message);
					return false;
				}

	- ###17.2.4 处理错误的策略
	- ###17.2.5 常见的错误类型
		- ####1. 类型转换错误
		- ####2. 数据类型错误
			- P509 大体上来说，基本类型的值应该使用 __typeof__ 来检测，而对象的值应该使用 __instanceof__ 来检测。
		- ####3. 通信错误
			- P510 encodeURIComponent()
	- ###17.2.6 区分致命错误和非致命错误
	- ###17.2.5 把错误记录到服务器
		- _P512 这里的 catch 后面为什么是 ex_
- ##17.3 调试技术
	- ###17.3.1 将消息记录到控制台
	- ###17.3.2 将消息记录到当前页面
	- ###17.3.3 抛出错误
- ##17.4 常见的 IE 错误
	- ###17.4.1 操作终止
	- ###17.4.2 无效字符
	- ###17.4.3 未找到成员
	- ###17.4.4 未知运行时错误
	- ###17.4.5 语法错误
	- ###17.4.6 系统无法找到指定资源
- ##17.5 小结

----
#第18章 JavaScript 与 XML
----
- P521 曾几何时，XML 一度成为存储和通过因特网传输__结构化数据__的标准
- ##18.1 浏览器对 XML DOM 的支持
	- _P521 DOM2 级是第一个提到__动态创建__ XML DOM 概念的规范_
	- ###18.1.1 DOM2 级核心
	- ###18.1.2 DOMParser 类型
	- ###18.1.3 XMLSerializer 类型
	- ###18.1.4 IE8 及之前版本中的 XML
		- ####1. 序列化 XML
		- ####2. 加载 XML 文件
	- ###18.1.5 跨浏览器处理 XML
- ##18.2 浏览器对 XPath 的支持
	- ###18.2.1 DOM3 级 XPath
		- ####1. 单节点结果
		- ####2. 简单类型结果
		- ####3. 默认类型结果
		- ####4. 命名空间支持
	- ###18.2.2 IE 中的 XPath
	- ###18.2.3 跨浏览器使用 XPath
- ##18.3 浏览器对 XSLT 的支持
	- ###18.3.1 IE 中的 XSLT
		- ####1. 简单的 XSLT 转换
		- ####2. 复杂的 XSLT 转换
	- ###18.3.2 XSLTProcessor 类型
		- ####1. 使用参数
		- ####2. 重置处理器
	- ###18.3.3 跨浏览器使用 XSLT
- ##18.4 小结

----
#第19章 E4X
----
- ##19.1 E4X 的类型
	- ###19.1.1 XML 类型
	- ###19.1.2 XMLList 类型
	- ###19.1.3 Namespace 类型
	- ###19.1.4 QName 类型
- ##19.2 一般用法
	- ###19.2.1 访问特性
	- ###19.2.2 其他节点类型
	- ###19.2.3 查询
	- ###19.2.4 构建和操作 XML
	- ###19.2.5 解析和序列化
	- ###19.2.6 命名空间
- ##19.3 其他变化
- ##19.4 全面启用 E4X
- ##19.5 小结

----
#第20章 JSON
----
- P562 结构化数据
- P562 很多编程语言都有针对 JSON的解析器和序列化器。
- P562 但 JSON 不支持 JS 中的特殊值 undefined
- P562 JSON 不支持变量、函数和对象实例，它就是一种表示结构化数据的格式，虽然与 JS 中表示数据的某些语法相同，但它并不局限于 JS 的范畴。
- ##20.1 语法
	- ###20.1.1 简单值
	- ###20.1.2 对象
	- ###20.1.3 数组
- ##20.2 解析与序列化
	- ###20.2.1 JSON 对象
		- _P566 在序列化 JS 对象时，所有函数及__原型成员__都会被有意忽略，不体现在结果中。此外，值为 undefined 的任何属性也都会被跳过。_
	- ###20.2.2 序列化选项
		- ####1. 过滤结果
			- _P567 此时返回传入的值，以便其他值都能正常出现在结果中_
		- ####2. 字符串缩进
		- ####3. toJSON() 方法
	- ###20.2.3 解析选项
- ##20.3 小结

----
#第21章 Ajax 与 Comet
----
- P571 另外，虽然名字中包含 XML 的成分，但 Ajax 通信与数据格式无关
- ##21.1 XMLHttpRequest 对象
	- ###21.1.1 XHR 的用法
	- ###21.1.2 HTTP 头部信息
	- ###21.1.3 GET 请求
	- ###21.1.4 POST 请求
- ##21.2 XMLHttpRequest 2级
	- ###21.2.1 FormData
	- ###21.2.2 超时设定
	- ###21.2.3 overrideMimeType() 方法
- ##21.3 进度事件
	- ###21.3.1 load 事件
	- ###21.3.2 progress 事件
- ##21.4 资源跨域共享
	- ###21.4.1 IE 对 CORS 的实现
	- ###21.4.2 其他浏览器对 CORS 的实现
	- ###21.4.3 Preflighted Requests
	- ###21.4.4 带凭据的请求
	- ###21.4.5 跨浏览器的 CORS
- ##21.5 其他跨域技术
	- ###21.5.1 图像 Ping
	- ###21.5.2 JSONP
	- ###21.5.3 Comet
	- ###21.5.4 服务器发送事件
	- ###21.5.5 Web Sockets
	- ###21.5.6 SSE 与 Web Sockets
- ##21.6 安全
- ##21.7 小结
